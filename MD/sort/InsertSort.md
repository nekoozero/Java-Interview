# 直接插入排序

直接插入排序算法是基于插入排序。工作原理类似于我们抓扑克牌。

![图片来自网络](https://images2015.cnblogs.com/blog/739525/201603/739525-20160329094816957-1860272498.jpg)

具体算法描述如下：

1. 从第一个元素开始，该元素可以认为已经被排序。
2. 取出下一个元素，在已经排序的元素序列中<strong>从后往前</strong>扫描。
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置。
4. 重复步骤三，知道找到已排序的元素小于或者等于新元素的位置。
5. 将新元素插入到该位置(小于等于新元素的后一个位置)后。
6. 重复步骤2~5。

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif)

具体代码实现：

```java
public void insertSort(){
    RecordNode p = new RecrodNode();
    for(int i=1;i<len;i++){             //进行len-1次扫描
        p=list[i];
        int j;
        for(j=i-1;j>=0;j--){           //比list[i]大的元素后移
            if(list[j].key>p.key){
                list[j+1]=list[j];
            }else{
                break;            //如果找到比list[i]小得元素就当前退出循环
            }
        }
        list[j+1]=p;                     //插入
    }
}

```


时间复杂度： 
有序表中捉个插入的操作进行了n-1趟，每趟的插入操作的时间主要耗费在关键字的比较和数据元素的移动上。
最好的情况下待排列的元素已按关键字值有序，每趟排序比较一次，移动两次，总的比较和移动次数为3(n-1)；最坏的情况下待排序的顺序表已按关键字值逆序排列，每趟比较i次，移动i+2次，总的比较和移动次数为n<sup>2</sup>+n;一般情况下，排序记录是随机序列，第i趟排序所需的比较和移动次数取平均值，约为i次，因此直接插入排序的时间复杂度为O(n<sup>2<sup>)。

空间复杂度：
由于其仅使用了一个辅助单元p，所以空间复杂度为O(1)。

算法稳定性：
使用直接插入排序后具有相同关键字的数据元素的位置关系与排序前相同，因此直接插入排序是一种稳定的排序算法。