# 快速排序

快速排序也属于交换排序的一类。

> 快速排序是冒泡排序的改进版，也是最好的一种内排序，还涉及到**分治**和**递归**。

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序(递归)，已达到整个序列有序。

基本步骤：
1. 设置两个变量low、high,分别表示待排序序列的起始下标和终止下标。
2. 设置变量p=list[low]。
3. 从下标为high的位置从后向前依次搜索，当找到第1个比p的关键字值小的记录时将该数据移动到下表为low的位置上，low加1。
4. 从下标为low的位置从前向后依次搜索，当找到第1个比p的关键字值大的记录时将该数据移动到小标为high的位置上，high-1.
5. 重复步骤（3）和（4），直到high=low位置。
6. list[low]=p。

![图片来自网络](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif)

具体代码：

```java
//分治  递归
  public static void quickSort(int[] arr) {
    int low = 0,high = arr.length-1;
    quickSort(arr,low,high);
    
  }
  private static void quickSort(int[] arr,int low,int high) {
    if(low<high) {
      //定位
      int index = partation(arr,low,high);
      quickSort(arr,low,index-1);
      quickSort(arr,index+1,high);
    }
    
  }

  //这个函数每执行一次，就把标准元素放到中间（元素大小）去，标准元素左边都是小于标准元素的  右边都是大于标准元素的
  private static int partation(int[] arr, int low, int high) {
    int p = arr[low];  //选取一个标准元素
    int i  = low;
    int j = high;
    while(i<j) {
      while(arr[j]>=p&&i<j) {
        j--;
      }
      if(i<j) {
        arr[i++] = arr[j];
      }
      while(arr[i]<=p&&i<j) {
        i++;
      }
      if(i<j) {
        arr[j--] = arr[i];
      }
    }
    //把开始节点放到中间位置
    arr[i] = p;
    return i;
  }
```

时间复杂度：
快速排序的执行时间与数据元素序列的初始排列以及基准值的选取有关。最坏情况下待排序序列基本有序，每次划分只能得到一个字序列，等同于冒泡排序，时间复杂度为O(n<sup>2</sup>),一般来说，对于具有n条记录的序列来说，一次划分需要进行n次关键字的比较，其时间复杂度为O(n)=O(nlog<sub>2</sub>n);

快速排序的基准值的选择方法有很多种，可以选取序列的中间值等，但由于数据元素序列的初始排列是随机的，不管如何选择基准值总会存在最坏情况。总之，当n较大并且数据元素序列随机排列时快速排序是快速的；当n很小或者基准值选取不合适时快速排序较慢。

空间复杂度：
快速排序需要额外存储空间来实现递归，递归调用的指针的参数都要存放到栈中。快速排序的递归过程可用递归树来表示。最坏情况下树为单支树，高度为O(n)，其空间复杂度为O(n)。若划分较为均匀，二叉树的高度为O(log<sub>2</sub>n),其空间复杂度也为O(log<sub>2</sub>n)。

算法稳定性：

快速排序是一种不稳定的排序算法。（相同数字排序后两个数字的相对顺序不一样了）  1 3 2 **3** --> 1 2 **3** 3


# tips 

排序算法分为：**比较排序**和**非比较排序**。

比较排序：

1. 插入排序：
   直接插入排序
   希尔排序
   折半插入排序

2. 选择排序：
   选择排序
   堆排序

3. 交换排序：
   冒泡排序
   快速排序

4. 归并排序：
   归并排序

非比较排序：

1. 计数排序
2. 基数排序

# 总结
1. 直接插入排序、简单选择排序、冒泡排序是最简单的三种排序，时间复杂度最高为O(n<sup>2</sup>)，作为基础排序。
2. 三种简单排序算法简单，但是效率低下；高级排序在简单排序基础上优化，算法基础，换取的是性能提高，但同时可能需要更多的辅助空间。
3. 快速排序和归并排序都是用了**分治和递归**。
4. 从时间性能上看，快速排序是所有排序算法中实际性能最好的，然而快速排序在最坏的情况下（数据基本有序）的时间性能不如堆排序和归并排序，并且时间复杂度高，所以更合适数据不大的情况。
5. 堆排序在任何情况下，其时间复杂度为O(nlog<sub>2</sub>n)。这相对于快速排序而言是**堆排序的最大优点**。堆排序在元素较少时由于消耗较多时间在初始建堆上，因此不值得提倡，然而当元素较多时还是很有效的排序算法。
6. 基于`比较`的排序的**时间复杂度下限是O(nlog<sub>2</sub>n)**,即这已经是最高的效率了。
7. 一个时间复杂度为O(n)的时间复杂度要使用非比较的排序（计数排序、基数排序）。前提条件是待排序的数要满足一定的范围的整数，而且可能需要较多的辅助空间。
8. 需要结合具体的需求和场景来选择甚至组合使用。才能达到高效稳定的目的。没有最好的排序，只有最合适的排序。