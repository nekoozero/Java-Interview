# 对象的内存布局

在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：**对头（Header）**、**实例数据（Instance Data）**、**对齐填充（Padding）**。

HotSpot 虚拟机的对象头包括两部分信息。

- 第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有锁、锁偏向线程 ID、偏向时间戳等，这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit ，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出 32 位、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，**Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息**,它会根据对象的状态复用自己的存储空间。

例如，在 32 位 HotSpot 虚拟机中，如果对象处于为被锁定的状态下，那么 Mark Word 的32bit 空间中的 25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0，而在其他状态（轻量级锁定、重量级锁定、GC 标记、可偏向）下对象的存储内容见下表

|存储内容|标志位|状态|
| -- | -- | -- |
|对象哈希码、对象分代年龄|01|未锁定|
|指向锁记录的指针|00|轻量级锁定|
|指向重量级锁的指针|10|膨胀（重量级锁定）|
|空，不需要记录信息|11|GC 标志|
|偏向线程 ID、偏向时间戳、对象分代年龄|01|可偏向|

- 对象头的另一部分是**类型指针**，即对象指向它的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。

> 另外，如果对象是一个数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。

接下来的**实例数据部分**`是对象真正存储的有效信息`，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在 Java 源码中定义顺序的影响。

第三部分**对齐填充**并不是必然存在的，也没有特别的含义，它仅仅是起着占位符的作用。由于 HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，也就是说，**对象的大小必须是 8 字节的整数倍**。而对象头部分正好是 8 字节的倍数（1 倍或者 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。