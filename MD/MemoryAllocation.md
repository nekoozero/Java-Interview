# Java 运行时的内存划分

![](https://ws1.sinaimg.cn/large/006tNc79ly1fmk5v19cmvj30g20anq3y.jpg)

## 程序计数器
程序计数器（Program Counter Register）是一块较小的内存空间，他可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器的工作就是通过改变这个计数器的直来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理。线程恢复等基础功能都需要依赖这个计数器来完成。

当多线程运行时，每个线程切换后需要知道上一次所运行的状态、位置。由此也可以看出程序计数器是每个线程**私有**的。各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。


## Java虚拟机栈
虚拟机栈由一个一个的栈帧组成，栈帧是在每一个方法调用时产生的。

java内存区分`堆内存（Heap）`和`栈内存（Stack）`，其实是很粗糙的说法。这种划分方式的流行只能说明程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分

虚拟机栈描述的是Java方法执行的内存模型：<strong>每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储`局部变量`、`操作数栈`、`动态链接`、`方法出口`等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</strong>

其中64为长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

> 如果出现方法递归调用出现死循环的话就会造成栈帧过多，即线程请求的栈深度大于虚拟机所允许的深度，最终会抛出 `stackoverflow` 异常。
> 
> 如果虚拟机栈可以动态扩展，并且扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

**这块内存区域也是线程私有的。生命周期与线程相同**。

## 本地方法栈
本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，他们的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。HotSpot直接就把本地方法栈和虚拟机栈合二为一。
与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

## Java 堆
`Java` 堆是整个虚拟机所管理的最大内存区域，几乎所有的对象创建都是在这个区域进行内存分配。

java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。

这块区域也是垃圾回收器重点管理的主要区域，从内存回收的角度来看，由于大多数垃圾回收器都采用`分代回收算法`，所有堆内存也分为 `新生代`、`老年代`，可以方便垃圾的准确回收。

从内存分配的角度来看，线程共享的Java'堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存贮的都仍然是对象实例，进一步划分的目的是为了更好的回收内存，或者更快的分配内存。

Java堆可以出与物理上不连续的内存空间，只要逻辑上连续的即可，就像我们的磁盘空间。

**这块内存属于线程共享区域。**

## 方法区

方法区主要用于存放已经被虚拟机加载的`类信息`、`常量`、`静态变量`、即时编译器编译后的代码等数据。在HotSpot虚拟机上，这块区域也被称为`永久代`。因为把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotpSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。

当方法区无法满足内存分布需求时，将抛出OutOfMemoryError异常。

**这块内存属于线程共享区域。**

## 运行时常量池

<strong>运行时常量池（Runtime Constant Pool）是方法区的一部分</strong>，其中存放了一些符号引用。Class文件中的除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池。`用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放`。

当常量池无法申请到内存时会抛出OutOfMemoryError异常。

## 直接内存
直接内存（Direct Memory）不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分也被频繁的使用，而且也可能导致OutOfMemoryError异常。
