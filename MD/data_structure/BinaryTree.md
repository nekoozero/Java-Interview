# 二叉树

1. 普通二叉树
二叉树是特殊的有序树，它也是由 n 个结点构成的有限集合。当 n=0 时称为空二叉树。二叉树的每个节点最多只有两个子树，子树也为二叉树，互不相交且有左右之分，分别称为左二叉树和右二叉树。

二叉树也是递归定义的，在书中定义的度，层次等属于同样也适用于二叉树。

2. 满二叉树
满二叉树是特殊的二叉树，他要求除叶结点外的其他结点都具有两棵子树，并且所有的叶结点都在同一层上。

3. 完全二叉树
完全二叉树是特殊的二叉树，若二叉树具有 n 个结点，他要求 n 个结点与满二叉树的前 n 个结点将拥有完全相同的逻辑结构。

![图片来自网络](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=8d434f8b349b033b3885f48874a75db6/6609c93d70cf3bc7c6549f63d100baa1cc112aec.jpg)

## 性质

性质1：二叉树中第 i 层的结点数最多为 2<sup>i-1</sup>。（根是第一层）

性质2：深度为 h 的二叉树最多有 2<sup>h</sup>-1个结点。

性质3：若二叉树的叶结点的个数为 n，度为 2 的结点个数为 m，有 n=m+1。

性质4：具有 n 个结点的完全二叉树，其深度为log<sub>2</sub><sup>n</sup>+1,log<sub>2</sub><sup>n</sup>是向下取整。

性质4：具有 n>=1 个结点的二叉树，其高度至多为n-1;高度至少为log<sub>2</sub><sup>n</sup>+1,log<sub>2</sub><sup>n</sup>是向下取整。

性质6：具有 n 个结点的完全二叉树，从根结点开始自上而下、从左向右对结点从 0 
开始编号。对于任意一个编号为 i 的结点：
    - 若 i=0,结点为根结点，没有父结点；若 i>0,则父结点的编号为 （i-1）/2。
    - 若 2i+1>=n,该结点无左孩子，否则左孩子结点的编号为 2i+1。
    - 若 2i+2>=n,该结点无右孩子，否则右孩子结点的编号为 2i+2。

## 存储结构

### 顺序存储结构

二叉树的顺序存储结构是指将二叉树的各个节点存放在一组地址连续的存储单元中，所有结点按节点序号进行顺序存储。因为二叉树为非线性结构，所以必须先将二叉树的结点排成线性序列再进行存储，实际上是对二叉树先进行了一次层次遍历。二叉树的各节点之间的逻辑关系由节点在线性序列中的相对位置确定。

为了存储非完全二叉树，需要在树中添加多余节点使其成为完全二叉树后进行存储，这样又会造成存储空间的浪费。

![图片来自网络](http://s3.51cto.com/wyfs02/M02/6E/04/wKiom1VxE9ay_VjbAADLEAsJrFA338.gif)

### 链式存储结构

二叉树的链式存储结构是指将二叉树的各个节点随机存放在存储空间中，二叉树的各个节点的逻辑关系由指针确定。每个节点至少要有两条链分别连接左右还自己诶点才能表达二叉树的层次关系。

根据指针域个数的不同，二叉树的链式存储结构由分一下两种：

1. 二叉树链式存储结构
   二叉树的每个节点设置两个指针域和一个数据与。数据域中存放节点的值，指针域中存放左右孩子结点的存储地址。
   采用二叉链表存储二叉树，每个节点只存储到了其孩子节点的单向关系，没有存储到其父节点的关系，因此要获得父节点将花费较多的时间，需要从根结点开始在二叉树中进行查找，所花费的时间是遍历部分二叉树的时间，且与查找节点所处的位置有关
2. 三叉链式存储结构
   二叉树的每个节点设置3个指针域和一个数据域。数据域中存放节点的值，指针域中存放左右节点和父节点的存储地址

   lchild->data->rchild  二叉链表节点
   parent->lchild->data->rchild  三叉链表节点（主要是为了寻找父节点）

两种链式存储结构各有优缺点，二叉链式存储结构空间利用率高，而三叉链式存储结构既便于查找孩子结点，又便于查找父结点。在实际应用中，二叉链式结构存储结构更加常用。

## 遍历方法

### 二叉树的遍历方法

1. 层次遍历
自上而下、从左到右访问每层的节点。
2. 先序遍历
先访问根节点，在先序遍历左子树，最后先序遍历右子树。
3. 中序遍历
先中序遍历左子树，在访问根节点，最后中序遍历右子树。
4. 后序遍历
先后序遍历左子树，最后遍历右子树，最后访问根节点。


仅以先序遍历为例子：

1. 二叉树遍历操作实现的递归算法

```java
//root是根节点
public void preOrder(Node root){
    System.out.println(root.data+" ");  //访问根节点
    preOrder(root.lchild);              //先序遍历左子树
    preOrder(root.rchild);              //先序遍历右子树
}
```

2. 二叉树遍历操作实现的非递归算法

二叉树遍历操作的递归算法结构简洁，亦易于实现，但是在时间上的开销很大，运行效率低，为了解决这个问题，可以将递归算法转换为非递归算法，转换方式有以下两种：

- 使用临时遍历保存中间结果，用循环遍历结构代替递归过程；
- 利用栈保存中间结果

二叉树遍历操作实现的非递归算法利用栈结构通过回溯访问二叉树的每个节点。

- 先序遍历

现需比那里从二叉树的根节点触发，沿着该节点的左子树向下搜索，每遇到一个节点先访问该节点，并将该节点的右子树入栈。先序遍历左子树完成后再从栈顶弹出有字数的根节点，然后采用相同的方法遍历右子树，知道二叉树的所有结点都被访问。其主要步骤如下：
1. 将二叉树的根节点入栈。
2. 若栈非空，将节点从栈中弹出并访问。
3. 依次访问当前节点的左孩子节点，并将当前节点的有孩子节点入栈。
4. 重复步骤2,3.

非递归的中序遍历：

```java
//root是根节点
public void inOrderByStack() {
    System.out.print("中序非递归遍历:");
    // 创建栈
    Deque<Node> stack = new LinkedList<Node>();
    Node current = root;
    while (current != null || !stack.isEmpty()) {
        while (current != null) {
            stack.push(current);
            current = current.leftChild;
        }
        if (!stack.isEmpty()) {
            current = stack.pop();
            System.out.print(current.value + " ");
            current = current.rightChild;
        }
    }
    System.out.println();   
}
```

- 层次遍历

层次遍历操作是从根节点触发，自上而下，从左到右依次遍历每层的节点，可以利用队列先进先出的特性进行实现。先将根节点入队，然后将队首节点出队并访问，都将其孩子结点依次入队：

1. 将根节点入队。
2. 若队非空，取出队首节点并访问，将队首节点的孩子结点入队。
3. 重复执行步骤2直到队为空。
层次遍历

```java
//root是根节点
public void levelOrderByStack() {
        System.out.print("层次遍历");
        Queue<Node> qu = new LinkedList();
        if(root==null) {
            return ;
        }
        qu.add(root);
        while(qu.size()!=0) {
            int len = qu.size();
            for(int i = 0;i<len;i++) {
                Node node = qu.poll();
                System.out.print(node.value+" ");
                //先将左结点放入
                if(node.leftChild!=null) {
                    qu.add(node.leftChild);
                }
                //再讲由节点放入
                if(node.rightChild!=null) {
                    qu.add(node.rightChild);
                }
            }
        }
    }
```

对于有n个结点的二叉树，因为每个节点都只访问一次，所以算法时间复杂度为O(n)。


## additional

### 二叉查找/搜索/排序/树 BST(binart serach/sort tree)

或者是一颗空树；

或者是具有下列性质的二叉树：

1. 若他的左子树不空，则左子树上所有结点的值均小于它的根节点的值。
2. 若他的右子树上所有结点的值均大于它的根节点的值。
3. 它的左右子树也分别为二叉排序树。

便于添加和排序。

![图片来自网络](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D0%2C0%2C1192%2C660%3Bc0%3Dbaike150%2C5%2C5%2C150%2C50/sign=353a0d9efaedab64603d1780ca0683f3/1ad5ad6eddc451da10fe7fbeb7fd5266d016325e.jpg)

**对二叉查找树进行中序遍历，得到有序集合。**

### 平衡二叉树

又称自平衡二叉查找树，实现之一是AVL树，避免出现偏移的情况(上图中的8,6,5,4节点)，查找某个节点的时间复杂度为O(log<sub>2</sub>n)，便于查找。

它是一个空树或者它的左右两个子树的高度差（平衡因子）的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树，同时，平衡二叉树必定是二叉搜索树，反之则不一定。

![图片来自网络](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D48%2C0%2C546%2C360%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d001be53a1ec8a1300550da0ca37a9a3/472309f790529822f523a37fdfca7bcb0a46d47e.jpg)

**平衡因子（平衡度）：**结点的平衡因子是结点的左子树的高度减去右子树的高度。

**平衡二叉树：**每个结点的平衡因子都为1，-1，0的二叉排序树。或者说每个结点的左右子树的高度最多差1的二叉排序树。



> 平衡二叉树的目的是为了减少二叉查找树层次，提高查找速度。<br>
> 平衡二叉树的杭常用实现方法有AVL、红黑树、替罪羊树、Treap、伸展树等

## 红黑树

R-B Tree,全称是Red-Black Tree,又称为“红黑树”，它是一种平衡二叉树（平衡二叉树的另一种实现）。红黑树的每个节点上都有存储位表示节点的颜色，可以是红（Red）或黑（Black）。

红黑树的特性：

1. 每个节点或是黑色，或是红色。
2. 根节点是黑色。
3. 每个叶子节点（NIL）是黑色。[注意：这里叶子节点，是指为空（NIL或Null）的叶子节点！]
4. 如果一个节点是红色的，则它的子节点必须是黑色的。
5. 从一个节点到该结点的子孙结点的所有路径上包含相同数目的黑节点。

注意：

特性3中的叶子节点，是只为空（NIL或null）的节点。

特性5，确保没有一条路径会比其他路径长出两倍。因而，红黑树是相对是接近平衡的二叉树。

![图片来自网络](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=cdd1dae17a0e0cf3b4fa46a96b2f997a/9358d109b3de9c828cdb8e7c6481800a18d84382.jpg)

> 红黑树的应用比较广泛，主要使用它来存储有序的数据，他的时间复杂度是O(log<sub>2</sub>n),效率非常之高。<br>
> 它虽然是复杂的，但他的最坏情况运行时间也是非常良好的，并且在实践中是高效的：他可以在O(log<sub>2</sub>n)时间内做查找，插入和删除，这里的n是树中元素的数目。<br>
> 例如，Java集合中的TreeSet和TreeMap,C++STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。

## B树（balanced tree）

与二叉平衡树相比，是多叉的，但也是平衡的，可以降低树的深度，提高查找效率。

B树应文件系统的要求而发展起来的，大量数据存放在外村中，通常存放在硬盘中。

由于是海量数据，不可能一次调入内存。因此，要多次访问外存。但硬盘的驱动机械运动的制约，速度慢。

所以主要矛盾变为减少访外存次数在1972年提出B_数作为索引组织文件。提高访问速度、减少时间。

![图片来自网络](https://img-blog.csdn.net/2018032420113990?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pfcnlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## B+树

在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；

**数据库索引的默认数据结构就是采用B+树**

![图片来自网络](https://img-blog.csdn.net/20180325001555181?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pfcnlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)