# 概念

算法是对特定问题求解步骤的一种描述，它是指令的优先序列，其中每一条指令表示一个或多个操作。还有 5 个重要的特性。

- **有穷性**
- **确定性** 
- **可行性**
- **输入** （0 个或多个）
- **输出** （1 个或多个）

算法至少有一个或多个输出，可以不需要输入。

# 时间复杂度

一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记作T(n),他是该算法问题规模 n 的函数，时间复杂度主要分析 T(n) 的数量级。算法中的基本运算（最**深层循环内**的语句）的频度与 T(n) 同数量级，所以通常采用算法中基本运算的频度 f(n) 来分析算法的时间复杂度。因此算法的时间复杂度记为：

**T(n)=O(f(n))**


**最坏时间复杂度**：在最坏的情况下，算法的时间复杂度。

**平均时间复杂度**：在所有可能输入实例在等概率出现的情况下，算法的期望运行时间。

**最好时间复杂度**：在最好的情况下，算法的时间复杂度。

一般总是考虑在最坏的情况下的时间复杂度，以保证算法的运行时间不会比它更长。

有两条规则：

a) 加法规则

b) 乘法规则

常见的渐近时间复杂度有：
O(1) < O(log<sub>2</sub>n) < O(n) < O(nlog<sub>2</sub>n) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)

# 空间复杂度

算法的空间复杂度 S(n)，定义该算法锁耗费的存储空间，他是问题规模 n 的函数。渐近空间复杂度也常称为空间复杂度，记作 S(n) = O(g(n))。
算法原地工作是指算法所需辅助空间是常量，即 O(1)。

## solution 

1.

```java
    int fun(int n) {
    	int i,j,k,s;
    	s = 0;
    	for(i=0;i<=n;i++) {
            for(j=0;j<=i;j++) {
            	for(k=0;k<=j;k++) {
            		s++;
            	}
            }
    	}
    	return s;
    }
```

T(n) = O(4);只是i,j,s,k这四个变量的变化。

由于算法中临时变量的个数与问题规模n无关，所以空间复杂度均为S(n)=O(1);

2.

```java
    void fun(int a[],int n,int k) {
    	int i;
    	if(k==n-1) {
    		for(i=0;i<n;i++) {
    			printf("%d\n0",a[i]);
    		}
    	} else {
            for(i=k;i<n;i++) {
            	a[i] = a[i]+i*i;
            }
            fun(a,n,k+1);       //递归
    	}
    }
```

每次调用本身都要分配空间，fun(a,n,0)的空间复杂度为O(n);

对于递归算法来说，代码一般都比较简短，算法本身所占用的存储空间较少，但运行时占用较多的临时工作单元。
递归效率低下，占用空间多，对性能要求不高的情况下可以用递归。
