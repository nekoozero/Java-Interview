# 对象的内存分布

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：`对象头（Header）、实例数据（InstanceData）和对象填充（Padding）`。

## 对象头

包括两部分：

### 第一部分

用于存储对象存储的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称为“Mark Word”。

- mark word被分成两部分，lock word和标志位。
- Klass ptr指向Class字节码在虚拟机内部的对象表示的地址。
- Fields表示连续的对象实例字段。

![对象](https://upload-images.jianshu.io/upload_images/2184951-a4d16925b1f3d421.png?imageMogr2/auto-orient/)

mark word 被设计为非固定的数据结构，以便在及小的空间内存储更多的信息。比如：在32位的hotspot虚拟机中：如果对象处于未被锁定的情况下。mark word 的32bit空间中有25bit存储对象的哈希码、4bit存储对象的分代年龄、2bit存储锁的标记位、1bit固定为0。而在其他的状态下（轻量级锁、重量级锁、GC标记、可偏向）下对象的存储结构为:
![对象头Mark Word](https://upload-images.jianshu.io/upload_images/2184951-96c64ed6c9f3316e.png?imageMogr2/auto-orient/)

### 第二部分

对象头的第二部分是类型指针，及对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

## 实例数据

是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录下来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义的顺序。

## 对齐填充

不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象示例数据部分没有对齐时，就需要通过对齐填充来补全。


