# 问题

在创建对象时，需要在堆上申请指定大小的内存，如果同时有大量线程申请内存的话，可以通过锁机制或者指针碰撞的方式确保不会申请到同一块内存，在 JVM 运行中，内存分配是一个及其频繁的动作，这种方式势必会降低性能。

因此，在 Hotspot 1.6 中的实现中引入了 TLAB 的技术。

# 什么是 TLAB（Thread Local Allocation Buffer）

在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个 Buffer，如果需要分配内存，就在自己的 Buffer 上分配，这样就不存在竞争的情况，可以大大提升分配效率，当 Buffer 容量不够的时候，再重新从 Eden 区域申请一块继续使用，这个申请动作还是需要原子操作的。

> 这样的目的是为新对象分配内存空间时，让每个 Java 应用线程能在使用自己专属的分配指针来分配空间，<strong>均摊</strong> GC 堆（eden区）里共享的分配指针做更新而带来的同步开销。

TLAB 只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其他线程无法在这个区域分配而已而已。当一个 TLAB 用满（分配指针 top 撞上分配极限 end 了），就新申请一个 TLAB，而在老 TLAB 里的对象还留在原地什么都不用管----它们无法感知自己是否曾经从 TLAB 分配出来的，而只关心自己是在 eden 里分配的。

TLAB 简单来说本质就是三个指针：start,top 和 end（实际实现中还有一些额外信息但这里不讨论）。

其中 start 和 end 是占位用的，标识出 eden 里被这个 TLAB 所管理的区域，卡住 eden 里的一块空间让其他线程别来这里分配了。而 top 就里面的分配指针，一开始就指向跟 start 同样的位置，然后逐渐分配，直到再要下一个对象就会撞上 end 的时候就会触发一次 TLAB refill。

> 注意 TLAB 有两层意思：一个是指存在管理 Java 线程的元数据对象 Java Thread 里的 Thread Local AllocBuffer 对象，它持有上述三个指针，仅用于管理而不存储对象自身；另一个是指在 eden 中分配出来的、被一个线程的 Thread Local AllocBuffer 所管理的一块内存，这才是实际存放对象的地方。现在我们把他们作为一个整体来看。

TLAB refill 包括下述几个动作：

- 将当前 TLAB 抛弃（retire）掉。这个过程中最重要的动作是将 TLAB 末尾尚未分配给 Java 对象的空间（浪费掉的空间）分配成一个假的“filler object”（目前使用 int[] 作为 filler object）。这是为了保持 GC 堆可以线性 parse(heap parseability)用的。
- 从 eden 新分配一块裸的空间出来（这一步可能会失败）
- 将新分配的空间范围记录到 Thread Local AllocBuffer 里 TLAB refill 不成功（eden 没有足够空间来分配这个新的 TLAB）就会触发 YGC。

“撞上”指的是在某次分配请求中，top + new_obj_size >= end 的情况，也就是说在被判定“撞上”的时候，top 常常离 end 还有一段距离，只是这之间的空间不足以满足新对象的分配请求 new_obj_size 的大小。这意味着在触发 TLAB refill 的时候，有可能会浪费掉位于该 TLAB 末尾的一部分空间：该 TLAB 已经占用了这块空间，所以其他线程无法在这里分配 java 对象，但该 TLAB 要 refill 的话它自己也不会在这块空间继续分配 Java 对象，从应用层面看这块空间就浪费了。

每次分配 TLAB 的大小是不固定的，而是每个线程根据该线程启动开始到现在的历史统计信息来自己单独调整的。如果一个线程上跑的代码的内存分配速率非常高，则该线程会选择使用更大的 TLAB 已达到均摊同步开销的效果，反之亦然；同时他还会统计浪费比例，并且将其放入计算新 TLAB 大小的考虑因素当中，把浪费比例控制在一定范围内。

> GC很重要的一点是对heap parseability的依赖。GC做某些需要线性扫描堆里的对象的操作时，需要知道堆里哪些地方有对象而哪些地方是空洞。一种办法是使用外部数据结构，例如freelist或者allocation BitMap之类来记录哪里有空洞；另一种办法是把空洞部分也假装成有对象，这样GC在线性遍历时会看到一个“对象总是连续分配的”的假象，就可以以统一的方式来遍历：遍历到一个对象时，通过其对象头记录的信息找出该对象的大小，然后跳到该大小之后就可以找到下一个对象的对象头，依此类推。HotSpot选择的是后者的做法，假装成有对象的这种东西就叫做filler object（填充对象）。

CollectedHeap 里的裸 allocate 动作是不关心分配的东西是什么类型的，只管在 GC 堆里看有没有地方可以分配，有的话 bump 分配指针并返回 bump 前的指针。TLAB 从 eden 重新分配空间就是问 CollectedHeap 再 allocate 一块这样的裸的空间，然后把这块空间的首尾记录到自己的 start 和 end 里去。

建议将 TLAB 翻译为线程私有分配区，而不是线程局部缓存这样词对词的直译。因为 TLAB 并不是一个缓存，而且他的重点也不是局部，而是让`那个分配指针称为线程私有的东西`。

无论是加锁还是 CAS，HotSpot 的共享堆分配都是用碰撞指针（pointer bumping/bump-the-pointer）来做的。加锁跟 bump 不在一个层面上，不应该并列。锁或者 CAS 只是同步的机制，实际想要做的事情都一样是 bump pointer。如果不需要与其他线程竞争的条件下，bump pointer 就不用同步保护。

例如在TLAB里，又例如在PLAB里，又例如在共享部分但在safepoint中没有竞争的情况下。

PLAB也是个非常有趣的东西，提到TLAB的话也可以顺带说下PLAB。

HotSpot里的TLAB是只在eden里分配的，用于给新建的小对象用。（本来其实也有考虑让TLAB在任意位置分配，但后来没实现）。PLAB则是在old gen里分配的一种临时的结构。就是笨神说的promotion LAB。

在多GC线程并行做YGC的时候，大家都要为了晋升对象而在old gen里分配空间，于是old gen的分配指针就热起来了。大量的竞争会使得并行度降低，所以跟TLAB用同样的思路，old gen在处理YGC的晋升对象的分配也一样可以用（GC）线程私有的分配区。这就是PLAB。另外在CMS里old gen的剩余空间不是连续的，而是有很多空洞。这些剩余空间是通过freelist来管理的。

如果ParNew要把对象晋升到CMS管理的old gen，不优化的话就得在freelist上做分配。于是就可以通过类似PLAB的方式，每个GC线程先从freelist申请一块大空间，然后在这块大空间里线性分配（bump pointer）。这样就既降低了对分配指针/freelist的竞争，又可以降低freelist分配的频率而转为用线性分配。

- [原文链接（狼哥）](https://www.jianshu.com/p/2343f2c0ecc4)
