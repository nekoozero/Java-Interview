# 概述

内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出站和入栈操作。因此这几个区域的内存分配和回收都具有确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自燃就跟随着回收了。

而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序运行期间时才能知道会创建那些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。

# 对象是否存活

## 引用计数法

给对象添加一个引用计数器，每当有一个地方放引用它时，计数器值就加 1；当引用失效时，计数器值就减一；任何时刻计数器为 0 的对象就是不可能在被使用的。

优点： 实现简单，判定效率也很高。
缺点： 很难解决对象间相互循环引用的问题。

例如：对象 objA 和 objB 都只有字段 instance，赋值令 objA.instance = objB 及 objB.instance = objA,除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是他们因为互相引用着对方，导致他们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们。

`Java 虚拟机里面没有选用引用计数法来管理内存。`

## 可达性分析算法

主流的商用程序语言（java、C#，甚至包括古老的 Lisp）的主流实现中，都是称通过可达性分析（Reachability Analysis）
来判定对象是否存活的。

基本思路：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），但一个对象到 GC Roots没有任何引用链相连时，证明此对象是不可用的。

![](https://img-blog.csdn.net/20170713090159517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUXVpbm5Ob3JyaXM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

在 Java 语言中，可作为 GC Roots 的对象包括下面几种：
- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中的类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中 JNI（一般说的 Native 方法）引用的对象。