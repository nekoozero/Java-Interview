# 引用

无论是通过计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判断对象是否存在都与“引用”有关。

jdk1.2 以前，Java 中的引用的定义很传统：如果 reference 类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。

但是我们希望能描述这样一类对象：`当内存控件还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。`很多系统的缓存功能都符合这样的应用场景。

jdk1.2 以后，将引用分为：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这 4 中引用强度依次逐渐减弱。

- 强引用：就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉引用的对象。
- 软引用：是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统就要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 jdk1.2 之后，提供了 SoftReference 类来实现软引用。
- 弱引用： 也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被软引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被软引用关联的对象。在 jdk1.2 之后，提供了 WeakReference 类来实现弱引用。
- 虚引用：称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其应用生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在 jdk1.2 之后，提供了 PhantomReference 类来实现虚引用。

# 生存还是死亡

即使是在可达性分析算法中不可达的对象，也并非是“非死不可”的，要宣告一个对象死亡，至少要经历两次标记过程：
1. 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象已经被覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都是为“没有必要执行”。
2. finalize() 对象是

>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。但不承诺会等待他运行结束，因为如果一个对象在 finalize() 方法中执行缓慢或者发生死循环，会导致内存回收系统崩溃。
