# G1（Garbage-First） 收集器

G1 是一款面向服务端应用的垃圾收集器。HotSpot 开发团队赋予它的使命是在未来科技替换掉 JDK1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点：

- 并行与并发：G1 能充分利用度 CPU、多核环境下的硬件优势，使用多个 CPU 来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- 分代收集：与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要与其他收集器配合就能独立管理整个 GC 堆，但他能够采用不同方式去处理新建的对象和已存在一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。
- 空间整合：G1 从整体上看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着 G1 工作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。
- 可预测的停顿：这是 G1 相对于 CMS 的一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿之外，还能建立可预测的停顿时间模型，能让使用这明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。

在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器的时候，Java 堆的内存布局就与其他收集器有很大差别，<strong>它将整个 Java 堆划分为多个大小相等的独立区域（Region）</strong>，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region （不需要连续）的集合。

> G1 收集器之所以能建立可预测的停顿时间模型，是因为他可以有计划的避免在整个 Java 堆中进行安全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这就是 Garbage-First 名称的由来）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高得收集效率。

如果不计算维护 Remebered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

- 初始标记（Initial Marking）
- 并发标记（Concurrent Marking）
- 最终标记（Final Marking）
- 筛选回收（Live Data Counting and Evacuation）

初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，但下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新的对象，这阶段需要停顿现成本，但耗时很短。并发标记阶段是从 GC Root 开始对堆中对象进行可行性分析，找出存活的对象，但这阶段耗时较长，但可与用户程序并发执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记阶段需要吧 Remembered Set Logs 的数据合并到 Remembered Set ，这阶段需要停止线程，但是可并行执行。最后在筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来指定回收计划。

![图片来自网络](https://images2015.cnblogs.com/blog/467583/201706/467583-20170628093914149-1103645311.png)

> 在 G1 收集器中，Region 之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用 Remembered Set 来避免全堆扫描的。G1 中每个 Region 都有一个与之对应的 Remembered Set，虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Writer Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之间（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的Region 的 Remembered Set 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remember Set即可保证不对全队扫描也不会有遗漏。