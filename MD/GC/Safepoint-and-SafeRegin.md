# HotSpot 的算法实现

## OopMap

从可达性分析从 GC Roots 节点找引用链这个操作为例，可作为 GC Roots 的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如战阵中的本地变量表）中，如果要逐个检查这里面的引用，那么必然会消耗很多时间。

可达性分析对执行时间的敏感还体现在<strong> GC 停顿</strong>上，因为这项分析工作必须在一个能确保一致性的快照中进行。这点是导致 GC 进行时必须停顿所有 Java 执行线程（Stop The World）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的 CMS （Concurrent Mark Sweep）收集群中，枚举根节点时也是必须要停顿的。

> “一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确行就无法得到保证。

目前的主流 Java 虚拟机使用的是准确式 GC，所以当执行系统停顿下来后，并不需要一个不漏地检查玩所有执行上下文和全局的引用的位置。在 HotSpot 的实现中，是使用一组称为<strong> OopMap </strong>的数据结构来达到这个目的，在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC 在扫描时就可以直接得知这些信息了。

## 安全点

在 OopMap 的协助下，HotSpot 可以快速且准确地完成 GC Roots 枚举。但一个很现实的问题随之而来：<strong>可能导致引用关系变化</strong>，或者说 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap ，那将会需要大量的额外空间，这样 GC 的空间成本将会变得很高。

所以，HotSpot 只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint）,即程序执行时并非在所有地方都能停顿下来开始 GC， 只有在到达安全点时才能暂停。Safepoint 的选定太少会导致 GC 等待时间太长，太多会导致过分增大运行时的负载。选定是以程序“是否具有让程序长时间执行的特征”为标准，最明显的特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生 Safepoint。

那么如何在 GC 发生时让所有的线程都“跑”到最近的安全点上再停顿下来。有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。几乎没有虚拟机采用抢先式中断来暂停线程而响应 GC 事件。

主动式中断的思想是：当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

## 安全区域

当线程处于 Sleep 状态或者 Blocked 状态，这是线程就无法响应 JVM 的中断请求，“走”到安全的地方去中断挂起，JVM 显然也不可能等待线程重新被分配 CPU 时间，对于这种情况，需要安全区域（Safe Region）来解决。

安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始 GC 都是安全的。也可以把 Safe Region 看作是被扩展了的 SafePoint。

在线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region，那样，当在这段时间里 JVM 要发起 GC 时，就不用管标识自己为 Safe Region 状态的线程了。在线程要离开 Safe Point 时，他要检查系统是否已经完成了根节点枚举（或者是整个 GC 过程），如果完成了，那线程就继续执行，否则他就必须等待直到收到可以安全离开 Safe Point 的信号为止。