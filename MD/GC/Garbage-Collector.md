<!-- MarkdownTOC -->

- [垃圾收集器](#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8)
	- [Serial 收集器](#serial-%E6%94%B6%E9%9B%86%E5%99%A8)
	- [ParNew 收集器](#parnew-%E6%94%B6%E9%9B%86%E5%99%A8)

<!-- /MarkdownTOC -->


<a id="%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"></a>
# 垃圾收集器

*如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。*

这里讨论的收集器基于 JDK1.7 Update 14 之后的 HotSpot 虚拟机，这个虚拟机包含的所有收集器如图所示：

![图片来自网络](https://img-blog.csdn.net/20170102225015393)

直到现在为止还没有最好的垃圾收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。

<a id="serial-%E6%94%B6%E9%9B%86%E5%99%A8"></a>
## Serial 收集器

这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明他只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是<strong>在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束</strong>。“Stop The World”这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用是难以接受的。

![图片来自网络](https://img-blog.csdn.net/20170102225015841)

到现在为止，它依然是虚拟机运行在 Client 模式下的默认新生代收集器。它也有着由于其他收集器的地方：<strong>简单而高效（与其他收集器的单线程相比）</strong>，对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。所以，Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择。

> HotSpot会根据自身版本和宿主机器的硬件性能自动选择运行模式，用户也可以使用“-client”或者“-server”来强制指定虚拟机运行在client模式或者server模式。<br/>
> 比如笔者在自己机器的命令行上直接敲入“java -version”, 可以看到是在serer模式下运行，并且采用mixed mode。<br/>
> 根据Oracle上的资料，结论是：64位的操作系统上只能采用server模式。看来Oracle认为server模式的激进优化在64位的操作系统上是优于client模式的简单优化的。

<a id="parnew-%E6%94%B6%E9%9B%86%E5%99%A8"></a>
## ParNew 收集器

ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多条线程进行垃圾回收之外，其余行为包括 Serial 收集器可用的所有控制参数、收集算法、Stop The World、对象分配原则、回收策略等都与 Serial 收集器完全一样。

![图片来自网络](https://img-blog.csdn.net/20170102225016331)

除了多线程收集之外，并没有太多创新之处，但它却是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，最重要的原因是：除了 Serial 收集器外，目前只有它能与 <strong>CMS</strong> 收集器配合工作。

ParNew 收集器在单 CPU 的环境中绝不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。当然，随着可以使用的 CPU 的数量的增加，他对于 GC 时系统资源的有效利用还是很有好处的。

> 在谈论垃圾收集器的上下文语境中：<br>
>    并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
>    并发（Concurrent）：指多用户线程与垃圾线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行与另一个 CPU 上。