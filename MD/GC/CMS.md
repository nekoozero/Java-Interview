# CMS 收集器（Concurrent Mark Sweep）

CMS 是一种`以获取最短回收停顿时间为目标的收集器`。目前很大一部分的 Java 应用集中在互联网或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。

CMS 是基于<strong>“标记 - 清除”</strong>算法实现的，分为四个步骤：

- 初始标记 (CMS initial mark)
- 并发标记 (CMS concurrent mark)
- 重新标记 (CMS remark)
- 并发清除 (CMS concurrent sweep)

> 初始标记、重新标记仍然需要“Stop The World”。初始标记仅仅是标记一下 GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是进行 GC Roots Tracing 的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。<br>
> 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从整体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。

![图片来自网络](https://img-blog.csdn.net/20170102225017372)

CMS 是一种并发低停顿收集器（Concurrent Low Pause Collector）。但还是有三个明显的缺点：

1. CMS 收集器对 CPU 资源非常敏感，它虽然不会导致应用程序停顿，但是会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。CMS 默认启动的回收线程数是（CPU数量 + 3）/4，也就是当 CPU 在 4 个以上时，并发回收时垃圾收集线程不少于 25%的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个时，CMS 对用户程序的影响就可能变得很大，如果本来 CPU 负载比较大，还分出一半的运算能力去执行收集线程，就可能导致用户程序的执行速度忽然降低了 50%。
2. CMS 收集器无法处理*浮动垃圾*（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次的 Full FC 的产生。也是由于在垃圾收集阶段用户线程还在继续运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发手机是的程序运作使用。如果在应用中老年代增长不是很快，可以适当提高参数 -XX:CMSInitiatingOccupancyFration 的值来提高触发百分比，以降低内存回收次数从而获取更好的性能。在 JDK1.6 中，CMS 收集器的启动阈值已经提升到 92%。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用 Serial Old数及其来重新进行老年代的垃圾收集，这样停顿时间就很长。所以说参数 -XX:CMSInitiatingOccupancyFration 设置得太高很容易导致大量“Concurrent Mode Failure”失败，性能反而降低。
> 浮动垃圾：由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为“浮动垃圾”。

3. CMS 是基于“标记 - 清除”算法的，意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够的连续空间来分配当前对象，不得不提前触发一次 Full GC。
> 为了解决这个问题，CMS 收集器提供了一个 -XX:+UseCMSCompactAtFullCollection 开关参数（默认就是开启的），用于在 CMS 收集器顶不住要进行 Full GC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片的问题是没有了，但停顿时间不得不变长。虚拟机还提供了另外一次参数 -XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的 Full GC 后，跟着来一次带压缩的（默认值为 0，表示每次进入 Full GC 时都要进行碎片整理）。